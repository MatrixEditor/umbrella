# Copyright (c) 2023 MatrixEditor
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from typing import final, ClassVar, List, Optional

import umbrellacxx

class TYPE:
    PVOID: ClassVar[PVOID] = ...
    OBJECT: ClassVar[OBJECT] = ...
    ARRAY: ClassVar[ARRAY] = ...
    STRUCT: ClassVar[STRUCT] = ...
    UNION: ClassVar[UNION] = ...
    BIT_FIELD: ClassVar[BIT_FIELD] = ...
    POINTER: ClassVar[POINTER] = ...
    ATTRIBUTES: ClassVar[ATTRIBUTES] = ...
    BLOCK: ClassVar[BLOCK] = ...
    VOID: ClassVar[VOID] = ...
    UNSIGNED_CHAR: ClassVar[UNSIGNED_CHAR] = ...
    CHAR: ClassVar[CHAR] = ...
    INT: ClassVar[INT] = ...
    UNSIGNED_INT: ClassVar[UNSIGNED_INT] = ...
    SHORT: ClassVar[SHORT] = ...
    UNSIGNED_SHORT: ClassVar[UNSIGNED_SHORT] = ...
    LONG: ClassVar[LONG] = ...
    UNSIGNED_LONG: ClassVar[UNSIGNED_LONG] = ...
    LONG_LONG: ClassVar[LONG_LONG] = ...
    UNSIGNED_LONG_LONG: ClassVar[UNSIGNED_LONG_LONG] = ...
    FLOAT: ClassVar[FLOAT] = ...
    DOUBLE: ClassVar[DOUBLE] = ...
    BOOL: ClassVar[BOOL] = ...
    STRING: ClassVar[STRING] = ...
    CLASS: ClassVar[CLASS] = ...
    SEL: ClassVar[SEL] = ...
    UNKNOWN: ClassVar[UNKNOWN] = ...
    NXATOM: ClassVar[NXATOM] = ...
    __name__: str = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __int__(self) -> int: ...

class ATTRIBUTE_TYPE:
    GETTER: ClassVar[GETTER] = ...
    SETTER: ClassVar[SETTER] = ...
    READONLY: ClassVar[READONLY] = ...
    COPY: ClassVar[COPY] = ...
    RETAIN: ClassVar[RETAIN] = ...
    NONATOMIC: ClassVar[NONATOMIC] = ...
    DYNAMIC: ClassVar[DYNAMIC] = ...
    WEAK: ClassVar[WEAK] = ...
    GARBAGE: ClassVar[GARBAGE] = ...
    __name__: str = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __int__(self) -> int: ...

class METHOD_TYPE:
    CONST: ClassVar[CONST] = ...
    IN: ClassVar[IN] = ...
    INOUT: ClassVar[INOUT] = ...
    OUT: ClassVar[OUT] = ...
    BYCOPY: ClassVar[BYCOPY] = ...
    BYREF: ClassVar[BYREF] = ...
    ONEWAY: ClassVar[ONEWAY] = ...
    ATOMIC: ClassVar[ATOMIC] = ...
    COMPLEX: ClassVar[COMPLEX] = ...
    __name__: str = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __int__(self) -> int: ...

class TypeNode:
    class it_children(umbrellacxx.it[TypeNode]):
        pass

    def get_type(self) -> TYPE: ...
    def get_attr_type(self) -> ATTRIBUTE_TYPE: ...
    @property
    def children(self) -> it_children: ...
    @property
    def type(self) -> int: ...
    @property
    def size(self) -> int: ...
    @property
    def alignment(self) -> int: ...
    @property
    def stack_size(self) -> int: ...
    @property
    def attributes(self) -> List[str]: ...
    @property
    def name(self) -> str: ...
    @property
    def parent(self) -> Optional[TypeNode]: ...

def typedesc(__encoded: str, /) -> TypeNode: ...
def decode(__desc: TypeNode, /) -> str: ...
def signature(__selector: str, __encoded: str, /) -> str: ...

@final
class Method(umbrellacxx.InProcess):
    @property
    def name(self) -> str: ...
    @property
    def signature(self) -> str: ...
    @property
    def impl(self) -> int: ...
    @property
    def relative_impl(self) -> int: ...
    def is_small(self) -> bool: ...
    def get_typedesc(self) -> TypeNode: ...
    def decode_signature(self) -> str: ...
    def get_decl(self) -> str: ...

@final
class Property(umbrellacxx.InProcess):
    @property
    def name(self) -> str: ...
    @property
    def mangled_attributes(self) -> str: ...
    def get_decoded_attributes(self) -> str: ...
    def get_decl(self) -> str: ...

@final
class IVar(umbrellacxx.InProcess):
    @property
    def name(self) -> bytes: ...
    @property
    def mangled_type_name(self) -> bytes: ...
    @property
    def size(self) -> int: ...
    @property
    def alignment(self) -> int: ...
    def get_type_name(self) -> str: ...
    def get_decl(self) -> str: ...

@final
class Protocol(umbrellacxx.InProcess):
    class it_methods(umbrellacxx.it[Method]):
        pass
    class it_protocols(umbrellacxx.it[Protocol]):
        pass
    class it_properties(umbrellacxx.it[Property]):
        pass
    @property
    def name(self) -> str: ...
    @property
    def flags(self) -> int: ...
    @property
    def required_instance_methods(self) -> Protocol.it_methods: ...
    @property
    def optional_instance_methods(self) -> Protocol.it_methods: ...
    @property
    def required_class_methods(self) -> Protocol.it_methods: ...
    @property
    def optional_class_methods(self) -> Protocol.it_methods: ...
    @property
    def protocols(self) -> Protocol.it_protocols: ...
    @property
    def instance_properties(self) -> Protocol.it_properties: ...
    def get_decl(self) -> str: ...

@final
class Class(umbrellacxx.InProcess):
    class it_methods(umbrellacxx.it[Method]):
        pass
    class it_protocols(umbrellacxx.it[Protocol]):
        pass
    class it_properties(umbrellacxx.it[Property]):
        pass
    class it_ivars(umbrellacxx.it[IVar]):
        pass
    @property
    def methods(self) -> Class.it_methods: ...
    @property
    def ivars(self) -> Class.it_ivars: ...
    @property
    def protocols(self) -> Class.it_protocols: ...
    @property
    def properties(self) -> Class.it_properties: ...
    @property
    def name(self) -> str: ...
    @property
    def flags(self) -> int: ...
    @property
    def super_class(self) -> Optional[Class]: ...
    @property
    def meta_class(self) -> Optional[Class]: ...
    def has_super_class(self) -> bool: ...
    def has_meta_class(self) -> bool: ...
    def get_decl(self) -> str: ...


@final
class Category(umbrellacxx.InProcess):
    class it_methods(umbrellacxx.it[Method]):
        pass
    class it_protocols(umbrellacxx.it[Protocol]):
        pass
    class it_properties(umbrellacxx.it[Property]):
        pass
    @property
    def name(self) -> str: ...
    @property
    def base_class(self) -> Optional[Class]: ...
    @property
    def instance_methods(self) -> Category.it_methods: ...
    @property
    def class_methods(self) -> Category.it_methods: ...
    @property
    def instance_properties(self) -> Category.it_properties: ...
    @property
    def base_protocols(self) -> Category.it_protocols: ...
    def is_extension(self) -> bool: ...
    def get_decl(self) -> str: ...

@final
class ABIObjectiveC(umbrellacxx.ABIBase):
    class it_categories(umbrellacxx.it[Category]):
        pass
    class it_protocols(umbrellacxx.it[Protocol]):
        pass
    class it_classes(umbrellacxx.it[Class]):
        pass
    @property
    def classes(self) -> ABIObjectiveC.it_classes: ...
    @property
    def protocols(self) -> ABIObjectiveC.it_protocols: ...
    @property
    def categories(self) -> ABIObjectiveC.it_categories: ...
    def get_class(self, __name: str, /) -> Optional[Class]: ...
    def get_category(self, __name: str, /) -> Optional[Category]: ...
    def get_protocol(self, __name: str, /) -> Optional[Protocol]: ...


def parse(file_name: str) -> Optional[ABIObjectiveC]: ...
